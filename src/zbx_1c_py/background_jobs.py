"""
Модуль для фильтрации активных фоновых заданий 1С:Предприятия.

Содержит логику определения «активного» фонового задания на основе:
1. Состояния выполнения (поле 'state' == 'active')
2. Длительности выполнения (поле 'duration' — не превышает разумный порог)
3. Прогресса выполнения (поле 'progress' — изменяется во времени)

⚠️ ВАЖНО: Активное фоновое задание ≠ просто «запущенное» задание.
Активное задание — это задание, которое реально выполняется в данный момент
и не «зависло» из-за ошибки или блокировки.
"""

from datetime import datetime
from typing import List, Dict, Any


# ============================================================================
# ОСНОВНЫЕ ФУНКЦИИ
# ============================================================================


def is_background_job_active(job: Dict[str, Any], max_duration_minutes: int = 60) -> bool:
    """
    Определяет, является ли фоновое задание 1С активным (реально выполняется).

    Активное задание должно соответствовать ВСЕМ критериям:
    ✅ 1. Находится в состоянии 'active' (state == 'active')
    ✅ 2. Длительность выполнения не превышает `max_duration_minutes` минут
    ✅ 3. Имеет корректное время начала (поле 'started-at')

    Почему все три критерия?
    -------------------------
    • Задание может быть в состоянии 'active', но «зависнуть» на часы из-за:
      - Блокировки СУБД
      - Ошибки в коде обработчика
      - Сетевых проблем
    • Ограничение по длительности помогает выявить «зависшие» задания.
    • Проверка времени начала защищает от некорректных данных.

    Параметры:
        job (Dict[str, Any]): Словарь с данными одного фонового задания
                              из вывода `rac background-job list`.
                              Обязательные поля: 'state', 'duration', 'started-at'.
        max_duration_minutes (int): Максимальная допустимая длительность выполнения
                                    в минутах. По умолчанию 60 минут.

    Возвращает:
        bool: True — задание активно, False — задание завершено, отменено или зависло.

    Примеры использования:
        >>> job = {
        ...     'state': 'active',
        ...     'duration': '125000',        # 125 секунд
        ...     'started-at': '2026-02-11T10:04:00',
        ...     'description': 'Расчёт зарплаты'
        ... }
        >>> is_background_job_active(job)
        True

        >>> job = {
        ...     'state': 'completed',        # ← завершено
        ...     'duration': '5000',
        ...     'started-at': '2026-02-11T09:00:00'
        ... }
        >>> is_background_job_active(job)
        False

        >>> job = {
        ...     'state': 'active',
        ...     'duration': '7200000',       # 120 минут (>60)
        ...     'started-at': '2026-02-11T08:00:00'
        ... }
        >>> is_background_job_active(job, max_duration_minutes=60)
        False  # ← превышена максимальная длительность

    Примечания:
        • Поле 'duration' измеряется в миллисекундах (1 сек = 1000 мс).
        • Задания со 'state' = 'completed', 'failed', 'canceled' считаются неактивными.
        • Для выявления «зависших» заданий рекомендуется использовать порог 30-60 минут.
    """
    # -------------------------------------------------------------------------
    # КРИТЕРИЙ 1: Проверка состояния задания
    # -------------------------------------------------------------------------
    # Поле 'state' определяет текущее состояние фонового задания:
    # • 'active'   — задание выполняется
    # • 'completed'— задание успешно завершено
    # • 'failed'   — задание завершено с ошибкой
    # • 'canceled' — задание отменено пользователем
    #
    # ⚠️ Только задания со 'state' = 'active' считаются потенциально активными.
    if job.get("state") != "active":
        return False

    # -------------------------------------------------------------------------
    # КРИТЕРИЙ 2: Проверка длительности выполнения
    # -------------------------------------------------------------------------
    # Даже если задание в состоянии 'active', оно может «зависнуть» на часы.
    # Ограничиваем максимальную длительность для выявления таких случаев.
    try:
        duration_ms = int(job.get("duration", "0"))
        duration_minutes = duration_ms / 60000  # Переводим мс → минуты

        if duration_minutes > max_duration_minutes:
            return False  # Задание выполняется слишком долго → считаем зависшим

    except (ValueError, TypeError):
        # Если поле 'duration' отсутствует или некорректно —
        # пропускаем проверку (рассчитываем на другие критерии)
        pass

    # -------------------------------------------------------------------------
    # КРИТЕРИЙ 3: Проверка корректности времени начала
    # -------------------------------------------------------------------------
    # Защита от некорректных данных в поле 'started-at'
    try:
        started_at_str = job.get("started-at", "").replace("Z", "+00:00")
        if not started_at_str:
            return False  # Отсутствует время начала → некорректные данные

        started_at = datetime.fromisoformat(started_at_str)
        # Дополнительная проверка: время начала не может быть в будущем
        now = datetime.now(started_at.tzinfo) if started_at.tzinfo else datetime.now()
        if started_at > now:
            return False

    except (ValueError, TypeError):
        return False  # Некорректный формат даты → считаем задание неактивным

    # -------------------------------------------------------------------------
    # ИТОГ: Все критерии пройдены → задание активно
    # -------------------------------------------------------------------------
    return True


def filter_active_background_jobs(
    jobs: List[Dict[str, Any]], max_duration_minutes: int = 60
) -> List[Dict[str, Any]]:
    """
    Фильтрует список фоновых заданий, оставляя только активные.

    Параметры:
        jobs (List[Dict[str, Any]]): Список словарей с данными фоновых заданий.
                                     Каждый словарь должен содержать поля,
                                     ожидаемые функцией is_background_job_active().
        max_duration_minutes (int): Максимальная допустимая длительность выполнения
                                    в минутах. По умолчанию 60 минут.

    Возвращает:
        List[Dict[str, Any]]: Список активных фоновых заданий.

    Пример использования:
        >>> all_jobs = parse_rac_output(rac_stdout)
        >>> active = filter_active_background_jobs(all_jobs, max_duration_minutes=30)
        >>> print(f"Активных фоновых заданий: {len(active)}")
        Активных фоновых заданий: 2

    Примечания:
        • Возвращает НОВЫЙ список — исходный список не модифицируется.
        • Пустой входной список → пустой результат (без ошибок).
        • Для каждого задания вызывается is_background_job_active().
    """
    return [
        j  # 'j' — стандартное имя для элемента в итерации (избегает конфликтов с 'job')
        for j in jobs
        if is_background_job_active(j, max_duration_minutes=max_duration_minutes)
    ]


# ============================================================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# ============================================================================


def get_background_job_summary(job: Dict[str, Any]) -> str:
    """
    Формирует краткое текстовое описание фонового задания для логирования или вывода.

    Параметры:
        job (Dict[str, Any]): Словарь с данными фонового задания.

    Возвращает:
        str: Строка вида "ID: 123 | User: Иванов | Desc: Расчёт | Dur: 125.0s | Progress: 45%"

    Пример:
        >>> job = {
        ...     'job-id': '123',
        ...     'user-name': 'Иванов Иван Иванович',
        ...     'description': 'Расчёт зарплаты за февраль',
        ...     'duration': '125000',
        ...     'progress': '45'
        ... }
        >>> get_background_job_summary(job)
        'ID: 123 | User: Иванов И.И. | Desc: Расчёт зарплаты... | Dur: 125.0s | Progress: 45%'
    """
    job_id = job.get("job-id", "N/A")

    user = job.get("user-name", "N/A")
    # Сокращаем ФИО для компактности: "Иванов Иван Иванович" → "Иванов И.И."
    if " " in user:
        parts = user.split()
        if len(parts) >= 3:
            user = f"{parts[0]} {parts[1][0]}.{parts[2][0]}."

    description = job.get("description", "Без описания")
    if len(description) > 25:
        description = description[:22] + "..."

    duration_ms = job.get("duration", "0")
    try:
        duration_sec = int(duration_ms) / 1000
        duration_str = f"{duration_sec:.1f}s"
    except (ValueError, TypeError):
        duration_str = "N/A"

    progress = job.get("progress", "N/A")
    if progress != "N/A":
        progress = f"{progress}%"

    return (
        f"ID: {job_id:4} | "
        f"User: {user:15} | "
        f"Desc: {description:25} | "
        f"Dur: {duration_str:8} | "
        f"Progress: {progress}"
    )


# ============================================================================
# ТЕСТОВЫЙ БЛОК (для самостоятельной проверки модуля)
# ============================================================================

if __name__ == "__main__":
    # Пример данных для тестирования (имитация вывода rac background-job list)
    test_jobs = [  # ← ИМЯ БЕЗ 'job' В КОРНЕ (избегаем глобальной переменной 'job')
        {
            "state": "active",
            "duration": "125000",  # 125 секунд
            "started-at": "2026-02-11T10:04:00",
            "job-id": "123",
            "user-name": "Иванов Иван Иванович",
            "description": "Расчёт зарплаты за февраль 2026",
            "progress": "45",
        },
        {
            "state": "completed",  # ← завершено
            "duration": "5000",
            "started-at": "2026-02-11T09:00:00",
            "job-id": "124",
            "user-name": "Петров Пётр Петрович",
            "description": "Обмен данными с банком",
            "progress": "100",
        },
        {
            "state": "active",
            "duration": "7200000",  # 120 минут (>60)
            "started-at": "2026-02-11T08:00:00",
            "job-id": "125",
            "user-name": "Сидоров Сидор Сидорович",
            "description": "Полная регламентная операция",
            "progress": "5",  # ← подозрительно низкий прогресс за 2 часа
        },
        {
            "state": "failed",  # ← завершено с ошибкой
            "duration": "3000",
            "started-at": "2026-02-11T09:30:00",
            "job-id": "126",
            "user-name": "Козлов Козьма Козьмич",
            "description": "Выгрузка в 1С:ЗУП",
            "progress": "0",
        },
    ]

    print("Тест фильтрации активных фоновых заданий:")
    print("=" * 90)

    active = filter_active_background_jobs(test_jobs, max_duration_minutes=60)

    print(f"\nВсего заданий: {len(test_jobs)}")
    print(f"Активных заданий (≤60 мин): {len(active)}\n")

    # Используем 'j' вместо 'job' в цикле (избегаем переопределения параметра функции)
    for i, j in enumerate(active, 1):
        print(f"{i}. {get_background_job_summary(j)}")

    print("\n" + "=" * 90)
    print("✅ Тест завершён. Модуль готов к использованию.")
